# -*- coding: utf-8 -*-
"""Tutorial - Regression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/pycaret/pycaret/blob/master/tutorials/Tutorial%20-%20Regression.ipynb

Last updated: 15 Feb 2023

# üëã PyCaret Regression Tutorial

PyCaret is an open-source, low-code machine learning library in Python that automates machine learning workflows. It is an end-to-end machine learning and model management tool that exponentially speeds up the experiment cycle and makes you more productive.

Compared with the other open-source machine learning libraries, PyCaret is an alternate low-code library that can be used to replace hundreds of lines of code with a few lines only. This makes experiments exponentially fast and efficient. PyCaret is essentially a Python wrapper around several machine learning libraries and frameworks, such as scikit-learn, XGBoost, LightGBM, CatBoost, spaCy, Optuna, Hyperopt, Ray, and a few more.

The design and simplicity of PyCaret are inspired by the emerging role of citizen data scientists, a term first used by Gartner. Citizen Data Scientists are power users who can perform both simple and moderately sophisticated analytical tasks that would previously have required more technical expertise.

# üíª Installation

PyCaret is tested and supported on the following 64-bit systems:
- Python 3.7 ‚Äì 3.10
- Python 3.9 for Ubuntu only
- Ubuntu 16.04 or later
- Windows 7 or later

You can install PyCaret with Python's pip package manager:

`pip install pycaret`

PyCaret's default installation will not install all the extra dependencies automatically. For that you will have to install the full version:

`pip install pycaret[full]`

or depending on your use-case you may install one of the following variant:

- `pip install pycaret[analysis]`
- `pip install pycaret[models]`
- `pip install pycaret[tuner]`
- `pip install pycaret[mlops]`
- `pip install pycaret[parallel]`
- `pip install pycaret[test]`
"""

# check installed version (must be >3.0)
import pycaret
pycaret.__version__

"""# üöÄ Quick start

PyCaret's Regression Module is a supervised machine learning module that is used for estimating the relationships between a dependent variable (often called the outcome variable, or target) and one or more independent variables (often called features, predictors, or covariates).

The objective of regression is to predict continuous values such as predicting sales amount, predicting quantity, predicting temperature, etc. Regression module provides several pre-processing features to preprocess the data for modeling through the setup function.

PyCaret's regression module has many preprocessing capabilities and it coems with over 25 ready-to-use algorithms and several plots to analyze the performance of trained models.

A typical workflow in PyCaret Regression module consist of the following 5 steps in this order:

### **Setup** ‚û°Ô∏è **Compare Models** ‚û°Ô∏è **Analyze Model** ‚û°Ô∏è **Prediction** ‚û°Ô∏è **Save Model**
<br/>
"""

### load sample dataset from pycaret dataset module
from pycaret.datasets import get_data
data = get_data('insurance')

"""## Setup
The `setup` function initializes the training environment and creates the transformation pipeline. Setup function must be called before executing any other function in PyCaret. It only has two required parameters i.e. `data` and `target`. All the other parameters are optional.
"""

# import pycaret regression and init setup
from pycaret.regression import *
s = setup(data, target = 'charges', session_id = 123)

"""Once the setup has been successfully executed it shows the information grid containing experiment level information.

- **Session id:**  A pseudo-random number distributed as a seed in all functions for later reproducibility. If no `session_id` is passed, a random number is automatically generated that is distributed to all functions.<br/>
<br/>
- **Target type:**  Binary, Multiclass, or Regression. The Target type is automatically detected. <br/>
<br/>
- **Original data shape:**  Shape of the original data prior to any transformations. <br/>
<br/>
- **Transformed train set shape :**  Shape of transformed train set <br/>
<br/>
- **Transformed test set shape :**  Shape of transformed test set <br/>
<br/>
- **Numeric features :**  The number of features considered as numerical. <br/>
<br/>
- **Categorical features :**  The number of features considered as categorical. <br/>

PyCaret has two set of API's that you can work with. (1) Functional (as seen above) and (2) Object Oriented API.

With Object Oriented API instead of executing functions directly you will import a class and execute methods of class.
"""

# import RegressionExperiment and init the class
from pycaret.regression import RegressionExperiment
exp = RegressionExperiment()

# check the type of exp
type(exp)

# init setup on exp
exp.setup(data, target = 'charges', session_id = 123)

"""You can use any of the two method i.e. Functional or OOP and even switch back and forth between two set of API's. The choice of method will not impact the results and has been tested for consistency.
___

## Compare Models

The `compare_models` function trains and evaluates the performance of all the estimators available in the model library using cross-validation. The output of this function is a scoring grid with average cross-validated scores. Metrics evaluated during CV can be accessed using the `get_metrics` function. Custom metrics can be added or removed using `add_metric` and `remove_metric` function.
"""

# compare baseline models
best = compare_models()

# compare models using OOP
# exp.compare_models()

best = create_model('catboost') #choose catboost to avoid plot errors with some models

"""Notice that the output between functional and OOP API is consistent. Rest of the functions in this notebook will only be shown using functional API only.

___

## Analyze Model

The `plot_model` function is used to analyze the performance of a trained model on the test set. It may require re-training the model in certain cases.
"""

# plot residuals
plot_model(best, plot = 'residuals')

# plot error
plot_model(best, plot = 'error')

# plot feature importance
plot_model(best, plot = 'feature')

# check docstring to see available plots
# help(plot_model)

"""An alternate to `plot_model` function is `evaluate_model`. It can only be used in Notebook since it uses `ipywidget`."""

evaluate_model(best)

"""___

## Prediction
The `predict_model` function returns `prediction_label` as new column to the input dataframe. When data is `None` (default), it uses the test set (created during the setup function) for scoring.
"""

# predict on test set
holdout_pred = predict_model(best)

# show predictions df
holdout_pred.head()

"""The same function works for predicting the labels on unseen dataset. Let's create a copy of original data and drop the `charges`. We can then use the new data frame without labels for scoring."""

# copy data and drop charges

new_data = data.copy()
new_data.drop('charges', axis=1, inplace=True)
new_data.head()

# predict model on new_data
predictions = predict_model(best, data = new_data)
predictions.head()

"""___

## Save Model

Finally, you can save the entire pipeline on disk for later use, using pycaret's `save_model` function.
"""

# save pipeline
save_model(best, 'my_first_pipeline')

# load pipeline
loaded_best_pipeline = load_model('my_first_pipeline')
loaded_best_pipeline

"""# üëá Detailed function-by-function overview

## ‚úÖ Setup
The `setup` function initializes the experiment in PyCaret and creates the transformation pipeline based on all the parameters passed in the function. Setup function must be called before executing any other function. It takes two required parameters: `data` and `target`. All the other parameters are optional and are used for configuring data preprocessing pipeline.
"""

s = setup(data, target = 'charges', session_id = 123)

"""To access all the variables created by the setup function such as transformed dataset, random_state, etc. you can use `get_config` method."""

# check all available config
get_config()

# lets access X_train_transformed
get_config('X_train_transformed')

# another example: let's access seed
print("The current seed is: {}".format(get_config('seed')))

# now lets change it using set_config
set_config('seed', 786)
print("The new seed is: {}".format(get_config('seed')))

"""All the preprocessing configurations and experiment settings/parameters are passed into the `setup` function. To see all available parameters, check the docstring:"""

# help(setup)

# init setup with normalize = True
s = setup(data, target = 'charges', session_id = 123,
          normalize = True, normalize_method = 'minmax')

# lets check the X_train_transformed to see effect of params passed
get_config('X_train_transformed')['age'].hist()

"""Notice that all the values are between 0 and 1 - that is because we passed `normalize=True` in the `setup` function. If you don't remember how it compares to actual data, no problem - we can also access non-transformed values using `get_config` and then compare. See below and notice the range of values on x-axis and compare it with histogram above."""

get_config('X_train')['age'].hist()

"""___

## ‚úÖ Compare Models
The `compare_models` function trains and evaluates the performance of all estimators available in the model library using cross-validation. The output of this function is a scoring grid with average cross-validated scores. Metrics evaluated during CV can be accessed using the `get_metrics` function. Custom metrics can be added or removed using `add_metric` and `remove_metric` function.
"""

best = compare_models()

"""`compare_models` by default uses all the estimators in model library (all except models with `Turbo=False`) . To see all available models you can use the function `models()`"""

# check available models
models()

"""You can use the `include` and `exclude` parameter in the `compare_models` to train only select model or exclude specific models from training by passing the model id's in `exclude` parameter."""

compare_tree_models = compare_models(include = ['dt', 'rf', 'et', 'gbr', 'xgboost', 'lightgbm', 'catboost'])

compare_tree_models

"""The function above has return trained model object as an output. The scoring grid is only displayed and not returned. If you need access to the scoring grid you can use `pull` function to access the dataframe."""

compare_tree_models_results = pull()
compare_tree_models_results

"""By default `compare_models` return the single best performing model based on the metric defined in the `sort` parameter. Let's change our code to return 3 top models based on `MAE`."""

best_mae_models_top3 = compare_models(sort = 'MAE', n_select = 3)

# list of top 3 models by MAE
best_mae_models_top3

"""Some other parameters that you might find very useful in `compare_models` are:

- fold
- cross_validation
- budget_time
- errors
- probability_threshold
- parallel

You can check the docstring of the function for more info.
"""

# help(compare_models)

"""## ‚úÖ Experiment Logging
PyCaret integrates with many different type of experiment loggers (default = 'mlflow'). To turn on experiment tracking in PyCaret you can set `log_experiment` and `experiment_name` parameter. It will automatically track all the metrics, hyperparameters, and artifacts based on the defined logger.
"""

# from pycaret.regression import *
# s = setup(data, target = 'charges', log_experiment='mlflow', experiment_name='insurance_experiment')

# compare models
# best = compare_models()

# start mlflow server on localhost:5000
# !mlflow ui

"""By default PyCaret uses `MLFlow` logger that can be changed using `log_experiment` parameter. Following loggers are available:
    
    - mlflow
    - wandb
    - comet_ml
    - dagshub
    
Other logging related parameters that you may find useful are:

- experiment_custom_tags
- log_plots
- log_data
- log_profile

For more information check out the docstring of the `setup` function.
"""

# help(setup)

"""## ‚úÖ Create Model
The `create_model` function trains and evaluates the performance of a given estimator using cross-validation. The output of this function is a scoring grid with CV scores by fold. Metrics evaluated during CV can be accessed using the `get_metrics` function. Custom metrics can be added or removed using `add_metric` and `remove_metric` function. All the available models can be accessed using the `models` function.
"""

# check all the available models
models()

# train linear regression with default fold=10
lr = create_model('lr')

"""The function above has return trained model object as an output. The scoring grid is only displayed and not returned. If you need access to the scoring grid you can use `pull` function to access the dataframe."""

lr_results = pull()
print(type(lr_results))
lr_results

# train linear regression with fold=3
lr = create_model('lr', fold=3)

# train linear regression with specific model parameters
create_model('lr', fit_intercept = False)

# train lr and return train score as well alongwith CV
create_model('lr', return_train_score=True)

"""Some other parameters that you might find very useful in `create_model` are:

- cross_validation
- engine
- fit_kwargs
- groups

You can check the docstring of the function for more info.
"""

# help(create_model)

"""## ‚úÖ Tune Model

The `tune_model` function tunes the hyperparameters of the model. The output of this function is a scoring grid with cross-validated scores by fold. The best model is selected based on the metric defined in optimize parameter. Metrics evaluated during cross-validation can be accessed using the `get_metrics` function. Custom metrics can be added or removed using `add_metric` and `remove_metric` function.
"""

# train a dt model with default params
dt = create_model('dt')

# tune hyperparameters of dt
tuned_dt = tune_model(dt)

"""Metric to optimize can be defined in `optimize` parameter (default = 'Accuracy'). Also, a custom tuned grid can be passed with `custom_grid` parameter."""

dt

# define tuning grid
dt_grid = {'max_depth' : [None, 2, 4, 6, 8, 10, 12]}

# tune model with custom grid and metric = MAE
tuned_dt = tune_model(dt, custom_grid = dt_grid, optimize = 'MAE')

# to access the tuner object you can set return_tuner = True
tuned_dt, tuner = tune_model(dt, return_tuner=True)

# model object
tuned_dt

# tuner object
tuner

"""The default search algorithm is `RandomizedSearchCV` from `sklearn`. This can be changed by using `search_library` and `search_algorithm` parameter."""

# tune dt using optuna
tuned_dt = tune_model(dt, search_library = 'optuna')

"""For more details on all available `search_library` and `search_algorithm` please check the docstring. Some other parameters that you might find very useful in `tune_model` are:

- choose_better
- n_iter
- early_stopping
- groups

You can check the docstring of the function for more info.
"""

# help(tune_model)

"""## ‚úÖ Ensemble Model

The `ensemble_model` function ensembles a given estimator. The output of this function is a scoring grid with CV scores by fold. Metrics evaluated during CV can be accessed using the `get_metrics` function. Custom metrics can be added or removed using `add_metric` and `remove_metric` function.
"""

# ensemble with bagging
ensemble_model(dt, method = 'Bagging')

# ensemble with boosting
ensemble_model(dt, method = 'Boosting')

"""Some other parameters that you might find very useful in `ensemble_model` are:

- choose_better
- n_estimators
- groups
- fit_kwargs
- return_train_score

You can check the docstring of the function for more info.
"""

# help(ensemble_model)

"""## ‚úÖ Blend Models

The `blend_models` function trains a `VotingRegressor` for select models passed in the `estimator_list` parameter. The output of this function is a scoring grid with CV scores by fold. Metrics evaluated during CV can be accessed using the `get_metrics` function. Custom metrics can be added or removed using `add_metric` and `remove_metric` function.
"""

# top 3 models based on mae
best_mae_models_top3

# blend top 3 models
blend_models(best_mae_models_top3)

"""Some other parameters that you might find very useful in `blend_models` are:

- choose_better
- weights
- optimize
- fit_kwargs
- return_train_score

You can check the docstring of the function for more info.
"""

# help(blend_models)

"""## ‚úÖ Stack Models

The `stack_models` function trains a meta-model over select estimators passed in the estimator_list parameter. The output of this function is a scoring grid with CV scores by fold. Metrics evaluated during CV can be accessed using the `get_metrics` function. Custom metrics can be added or removed using `add_metric` and `remove_metric` function.
"""

# stack models
stack_models(best_mae_models_top3)

"""Some other parameters that you might find very useful in `stack_models` are:

- choose_better
- meta_model
- restack
- optimize
- return_train_score

You can check the docstring of the function for more info.
"""

# help(stack_models)

"""## ‚úÖ Plot Model

The `plot_model` function analyzes the performance of a trained model on the hold-out set. It may require re-training the model in certain cases.
"""

# plot residuals
plot_model(best, plot = 'residuals')

# to control the scale of plot
plot_model(best, plot = 'residuals', scale = 2)

# to save the plot
plot_model(best, plot = 'residuals', save=True)

"""Some other parameters that you might find very useful in `plot_model` are:

- fit_kwargs
- plot_kwargs
- groups
- display_format

You can check the docstring of the function for more info.
"""

# help(plot_model)

"""## ‚úÖ Interpret Model

The `interpret_model` function analyzes the predictions generated from a trained model. Most plots in this function are implemented based on the SHAP (Shapley Additive exPlanations). For more info on this, please see https://shap.readthedocs.io/en/latest/
"""

# train lightgbm model
lightgbm = create_model('lightgbm')

# interpret summary model
interpret_model(lightgbm, plot = 'summary')

# reason plot for test set observation 1
interpret_model(lightgbm, plot = 'reason', observation = 1)

"""Some other parameters that you might find very useful in `interpret_model` are:

- plot
- feature
- use_train_data
- X_new_sample
- y_new_sample
- save

You can check the docstring of the function for more info.
"""

# help(interpret_model)

"""## ‚úÖ Get Leaderboard

This function returns the leaderboard of all models trained in the current setup.
"""

# get leaderboard
lb = get_leaderboard()
lb

# select the best model based on MAE
lb.sort_values(by='MAE', ascending=True)['Model'].iloc[0]

"""Some other parameters that you might find very useful in `get_leaderboard` are:

- finalize_models
- fit_kwargs
- model_only
- groups

You can check the docstring of the function for more info.
"""

# help(get_leaderboard)

"""## ‚úÖ AutoML
This function returns the best model out of all trained models in the current setup based on the optimize parameter. Metrics evaluated can be accessed using the `get_metrics` function.
"""

# find best model based on CV metrics
automl()

"""## ‚úÖ Dashboard
The dashboard function generates the interactive dashboard for a trained model. The dashboard is implemented using `ExplainerDashboard`. For more information check out [Explainer Dashboard.](explainerdashboard.readthedocs.io)
"""

# dashboard function
dashboard(dt, display_format ='inline')

"""## ‚úÖCreate App
This function creates a basic gradio app for inference.
"""

# create gradio app
create_app(best)

"""## ‚úÖ Create API
This function takes an input model and creates a POST API for inference.
"""

# create api
create_api(best, api_name = 'my_first_api')

# !python my_first_api.py

# check out the .py file created with this magic command
# %load my_first_api.py

"""## ‚úÖ Create Docker
This function creates a `Dockerfile` and `requirements.txt` for productionalizing API end-point.
"""

create_docker('my_first_api')

# check out the DockerFile file created with this magic command
# %load DockerFile

# check out the requirements file created with this magic command
# %load requirements.txt

"""## ‚úÖ Finalize Model
This function trains a given model on the entire dataset including the hold-out set.
"""

final_best = finalize_model(best)

final_best

"""## ‚úÖ Convert Model
This function transpiles the trained machine learning model's decision function in different programming languages such as Python, C, Java, Go, C#, etc. It is very useful if you want to deploy models into environments where you can't install your normal Python stack to support model inference.
"""

# transpiles learned function to java
print(convert_model(dt, language = 'java'))

"""## ‚úÖ Deploy Model
This function deploys the entire ML pipeline on the cloud.

**AWS:**  When deploying model on AWS S3, environment variables must be configured using the command-line interface. To configure AWS environment variables, type `aws configure` in terminal. The following information is required which can be generated using the Identity and Access Management (IAM) portal of your amazon console account:

- AWS Access Key ID
- AWS Secret Key Access
- Default Region Name (can be seen under Global settings on your AWS console)
- Default output format (must be left blank)

**GCP:** To deploy a model on Google Cloud Platform ('gcp'), the project must be created using the command-line or GCP console. Once the project is created, you must create a service account and download the service account key as a JSON file to set environment variables in your local environment. Learn more about it: https://cloud.google.com/docs/authentication/production

**Azure:** To deploy a model on Microsoft Azure ('azure'), environment variables for the connection string must be set in your local environment. Go to settings of storage account on Azure portal to access the connection string required.
AZURE_STORAGE_CONNECTION_STRING (required as environment variable)
Learn more about it: https://docs.microsoft.com/en-us/azure/storage/blobs/storage-quickstart-blobs-python?toc=%2Fpython%2Fazure%2FTOC.json
"""

# deploy model on aws s3
# deploy_model(best, model_name = 'my_first_platform_on_aws',
#             platform = 'aws', authentication = {'bucket' : 'pycaret-test'})

# load model from aws s3
# loaded_from_aws = load_model(model_name = 'my_first_platform_on_aws', platform = 'aws',
#                              authentication = {'bucket' : 'pycaret-test'})

# loaded_from_aws

"""## ‚úÖ Save / Load Model
This function saves the transformation pipeline and a trained model object into the current working directory as a pickle file for later use.
"""

# save model
save_model(best, 'my_first_model')

# load model
loaded_from_disk = load_model('my_first_model')
loaded_from_disk

"""## ‚úÖ Save / Load Experiment
This function saves all the experiment variables on disk, allowing to later resume without rerunning the setup function.
"""

# save experiment
save_experiment('my_experiment')

# load experiment from disk
exp_from_disk = load_experiment('my_experiment', data=data)

